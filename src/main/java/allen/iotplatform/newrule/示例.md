##示例

####1. 单独数据包判断
此处以“冲顶困人”为例，该预警的描述是“P386与有人” 

~~~json
{
  "lg_name": "S102",                    // 逻辑单元名称，S102（冲顶困人） 
  "dep_logic": ["person"],              // 此逻辑依赖于名为person（有无人）的逻辑单元
  "condition": {  
    "con1": "__ROOMMAINTAIN == 0",      // 条件元素1：检修标记为0
    "con2": "__P386 == 1",              // 条件元素2：第386位为1
    "con3": "inner_person_state == 1"   // 条件元素3：执行person逻辑单元后得到的有无人标记为1，这处也说明了
                                        //    为什么需要先执行person逻辑，以及逻辑单元之间是通过公用的内部 
                                        //    逻辑变量所互相影响的（数据耦合关系）
  },  
  "logic": {  
    "con1 && con2 && con3": {           // 条件组合，条件元素1、2、3均为真的条件
      "S102": 1                         // 如果满足条件组合，此处将输出参数S102标记为1
    }  
  }  
}
~~~

> **说明：**  
> 1. ***lg_name*** 是逻辑名称，在整个模板中应保持唯一。  
> 2. ***dep_logic*** 是依赖描述，由于逻辑单元之间原则上是独立无关的，因此如果遇到某个逻辑单元的执行需要依赖其他逻辑单元执行结果的情况，就需要指定其所依赖的单元，引擎会根据此依赖先执行被依赖的逻辑单元。  
> 3. ***condition*** 是条件单元，是最基本的元素，最终此单元的计算结果是通过此处多个元素的“与、或、非”所组成。期间使用到的参数，只能是输入参数或是内部逻辑变量  
> 4. ***logic*** 是此逻辑单元的计算节点，根据基本元素的组合，此处会为条件为true的组合进行赋值操作，赋值的对象是内部逻辑变量和最终输出的参数。模板中所有的逻辑单元执行完成后，所有输出参数列表中变量会被引擎输出。此处在编写中，一般包括三方面的条件：  
> > (1) 达成此逻辑单元判断目标的组合  
> > (2) 初始化条件组合  
> > (3) 中间能进行操作（例如计数）的条件组合  
> > (4) 将内部状态还原的条件组合

----
####2. 单独数据包与上条数据结合判断
此处以“有人没人”判断为例，该判断的描述如下：  

* 触发条件1，判断“有人”，在收到的数据包中“P11=0”时，如果“people=1”，则标记为“有人”；如果“people=0”，则对原来有人无人状态不变动
* 触发条件2，判断“无人”，在收到数据包中“P11=1 并且 P12=1 并且 P15=1”，则标记为“无人”。
* 系统在没有满足以上触发条件的时候，不变更有人无人的状态。

~~~json
{
  "lg_name": "person",
  "dep_logic": [],
  "condition": {
    "con1": "__P11 == 0",           // 条件元素1：第11位为0
    "con2": "__P11 == 1",           // 条件元素2：第11位为1
    "con3": "__P12 == 1",           // 条件元素3：第12位为1
    "con4": "__P15 == 1",           // 条件元素4：第15位为1
    "con5": "__PEOPLE_FLAG == 1"    // 条件元素5：上一个数据包的是否有人状态为1
  },
  "logic": {
    "con1 && con5": {               // 如果P11=0并且上一条为有人（条件元素1、5的组合）
      "inner_person_state": 1,      // 将内部变量的有无人标记赋值，以被其他逻辑单元使用
      "PEOPLE": 1                   // 将输出的有人标记参数赋值
    },
    "con1 && !con5": {              // 如果P11=0并且上一条为没有人
      "inner_person_state": "__PEOPLE_LAST_FLAG",   // 有无人状态与上一条相同，不改变
      "PEOPLE": "__PEOPLE_LAST_FLAG"
    },
    "con2 && con3 && con4": {       // 如果P11=1并且P12=1并且P15=1
      "inner_person_state": 0,      // 有无人状态标记为无人0
      "PEOPLE": 0
    },
    "else": {                       // 以上条件都不满足，有无人状态不改变与上条相同
      "inner_person_state": "__PEOPLE_LAST_FLAG",
      "PEOPLE": "__PEOPLE_LAST_FLAG"
    }
  }
}
~~~

----
####3. 多个数据包连续性判断  
此处以“门区外停车困人”为例，该预警的描述是“连续10秒收到P381为1与有人”   

~~~json
{
  "lg_name": "S101",
  "dep_logic": ["person"],
  "condition": {
    "con1": "__ROOMMAINTAIN == 0",          // 条件元素1：检修标记为0
    "con2": "__P381 == 1",                  // 条件元素2：第381位为1
    "con3": "inner_S101_start_time > 0",    // 条件元素3：内部变量（记录持续时间）大于0，
                                            //   此处代表此内部变量已被赋值（初始值为0）
    "con4": "(__NOW - inner_S101_start_time) >= 10",  // 条件元素4：当前时间与记录的内部变量所表示的时间的差值大于等于10秒
    "con5": "inner_person_state == 1"       // 条件元素5：当前有人（此处是person逻辑执行结果）
  },
  "logic": {
    "con1 && con2 && con3 && con4 && con5": {  // 此处表示，非检修状态，收到381为1，根据时间戳计算持续10秒，判断为有人
      "S101": 1    
    },
    "con1 && con2 && !con3 && con5": {         // 此处表示，非检修，有人，收到381为1，并且是第一次收到（381位=为1），应该开始计时
      "inner_S101_start_time": "__NOW"
    },
    "!con2": {                                 // 此处表示，收到381为0的数据包，需要清空内部状态，还原原始状态
      "inner_S101_start_time": 0
    }
  }
}
~~~

----
####4. 包含前提条件的，多个数据包连续性判断  
此处以“超速困人”为例，该预警的描述是“P384=1出现后，连续10秒内，没有收到P386=1，并且有人”  

~~~json
{
  "lg_name": "S105",
  "dep_logic": ["person"],
  "condition": {
    "con1": "__ROOMMAINTAIN == 0",        // 条件元素1：检修标记为0
    "con2": "__P384 == 1",                // 条件元素2：第384位为1
    "con3": "__P386 == 1",                // 条件元素3：第386位为1
    "con4": "inner_S105_start_time > 0",  // 条件元素4：内部变量（记录持续时间）大于0
    "con5": "(__NOW - inner_S105_start_time) >= 10", // 条件元素5：当前时间与记录的内部变量所表示的时间的差值大于等于10秒
    "con6": "inner_person_state == 1"     // 条件元素6：当前有人（此处是person逻辑执行结果）
  },
  "logic": {
    "con1 && !con3 && con4 && con5 && con6": {  // 此处表示，非检修，P386不为1，持续时间不小于10秒，有人
      "S105": 1
    },
    "con1 && con2 && !con4 && con6": {    // 此处表示，是判断起始条件，开始记录起始时间非检修，P384为1，之前没有开始，
                                          //   有人，此时对内部时间变量开始计数
      "inner_S105_start_time": "__NOW"
    },
    "con3": {                             // 此处表示，无论任何时间，只要收到P386为1的数据，都表示不满足此逻辑单元的条件，
                                          //   需要还原初始状态
      "inner_S105_start_time": 0
    }
  }
}
~~~

----
####5. 多个数据包非连续性计数判断  
此处以“电梯频繁复位”为例，该预警的描述是“24小时5次以上出现E152，连续出现E152认为是1次”   

~~~json
{
  "lg_name": "S220",
  "dep_logic": [],
  "condition": {
    "con1": "__ROOMMAINTAIN == 0",         // 条件元素1：检修标记为0
    "con2": "__ERROR_3 == 'E152'",         // 条件元素2：出现E152
    "con3": "inner_S220_start_time > 0",   // 条件元素3：内部计时已经启动
    "con4": "(__NOW - inner_S220_start_time) <= 86400",  // 条件元素4：是否已经持续24小时
    "con5": "inner_S220_count > 5",        // 条件元素5：内部计数器是否已经到达5次
    "con6": "__E152_LAST == 0"             // 条件元素6：上一个数据包中是否包含E152
  },
  "logic": {
    "con1 && con3 && con4 && con5": {      // 此处表示，非检修，在24小时以内，次数已经大于5次
      "S220": 1
    },
    "con1 && con2 && !con3": {             // 此处表示，是起始记录判断，非检修，收到E152，第一次收到
      "inner_S220_start_time": "__NOW",
      "inner_S220_count": 1
    },
    "con1 && con2 && con3 && con4 && con6": {  // 此处表示，是中间进行计数的判断，非检修，收到E152，且前一个包不是E152，
                                               //   持续时间没有到达24小时
      "inner_S220_count": "inner_S220_count + 1"
    },
    "con3 && !con4": {                     // 此处表示，是清除内部状态判断，时间已超过24小时
      "inner_S220_start_time": 0,
      "inner_S220_count": 0
    }
  }
}
~~~

